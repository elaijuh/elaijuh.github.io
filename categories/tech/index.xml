<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on moo...</title>
    <link>https://blog.hujiale.me/categories/tech/</link>
    <description>Recent content in Tech on moo...</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 21 Dec 2016 22:18:43 +0800</lastBuildDate>
    <atom:link href="https://blog.hujiale.me/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Provision AWS Lightsail with Ansible</title>
      <link>https://blog.hujiale.me/post/provision-lightsail-with-ansible/</link>
      <pubDate>Wed, 21 Dec 2016 22:18:43 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/provision-lightsail-with-ansible/</guid>
      <description>

&lt;p&gt;Amazon has announced a new cloud service &lt;strong&gt;Lightsail&lt;/strong&gt; recently aiming at DigitalOcean, with exact same price and same spec of node.  As a heavy DigitalOcean user, I am more than happy to try the alternative provided by AWS. Creating the first instance is not smooth, I got successfully created the first instance by AWS SDK after 3 weeks in and out mails with the support team.&lt;/p&gt;

&lt;p&gt;TL;DR&lt;/p&gt;

&lt;p&gt;This post is a quick guide on provisioning the instance by Ansible.  Before that ,  some outlines:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The default login account for Lightsail is pretty much depended on the image, while in DigitalOcean it is &lt;strong&gt;root&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Lightsail is using key pair (.pem) for ssh login, you can either use default key pair or create a new pair. After successfully log into the instance, I added a pub ssh id by my preference.&lt;/li&gt;
&lt;li&gt;Everything in docker, as well as ansible&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ansible-playbook&#34;&gt;Ansible playbook&lt;/h2&gt;

&lt;p&gt;provision.yml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;---
- hosts: cloud 
  gather_facts: False
  tasks:
    - name: Update local known_hosts
      local_action: shell ssh-keyscan -H {{ hostvars[item].ansible_host }} &amp;gt;&amp;gt; ~/.ssh/known_hosts
      with_items: &amp;quot;{{ groups.cloud }}&amp;quot;

    - name: Install aptitude
      raw: test ! -e /usr/bin/aptitude &amp;amp;&amp;amp; sudo apt-get install -qq aptitude || true

    - name: Install python 2.7
      raw: test ! -e /usr/bin/python &amp;amp;&amp;amp; (sudo apt-get update -qq &amp;amp;&amp;amp; sudo apt-get install -qq python2.7) || true

    - name: Install letsencrypt 
      raw: test ! -e /usr/bin/letsencrypt &amp;amp;&amp;amp; (sudo apt-get update -qq &amp;amp;&amp;amp; sudo apt-get install -qq letsencrypt) || true

- hosts: cloud 
  roles:
    - update-apt
    - user
    - swap

- hosts: cloud 
  roles:
    # https://github.com/angstwad/docker.ubuntu
    - role: angstwad.docker_ubuntu
      become: yes
      kernel_pkg_state: present
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;provision.ini&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ini&#34;&gt;[hosts]
[YOUR_LIGHTSAIL_INSTANCE_NAME] ansible_host=[YOUR_IP] private_ip=[YOUR_PRIVATE_IP]

[cloud:children]
hosts

[cloud:vars]
ansible_connection=ssh
ansible_user=ubuntu
ansible_ssh_private_key_file=~/.ssh/id_rsa
ansible_python_interpreter=/usr/bin/python2.7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looking at &lt;code&gt;provision.yml&lt;/code&gt; , the first 3 common tasks are pretty straight forward:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Adding remote instance IP to your local known_hosts&lt;/li&gt;
&lt;li&gt;Install Python&lt;/li&gt;
&lt;li&gt;Install letsencrypt for HTTPS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Followed by 3 common roles:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Update and upgrade apt&lt;/li&gt;
&lt;li&gt;Create application user in sudo group&lt;/li&gt;
&lt;li&gt;Specify swap file (optional)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I would like to pick user role as example&lt;/p&gt;

&lt;p&gt;ansible/roles/user/tasks/main.yml&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;---
- name: Ensure user exists
  become: yes
  user:
    name: appuser
    state: present
    shell: /bin/bash
    append: yes 
    groups: sudo

- name: Ensure authorized key exists
  become: yes
  authorized_key: user=appuser key=&amp;quot;{{ lookup(&#39;file&#39;, &#39;~/.ssh/id_rsa.pub&#39;) }}&amp;quot;

- name: Copy sudoers
  become: yes
  copy: src=./sudoers dest=/etc/sudoers
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This role will create a user &lt;code&gt;appuser&lt;/code&gt; in sudo group for application deploy.  So that we don’t need to use the default user &lt;code&gt;ubuntu&lt;/code&gt; every time. Make sure you have added the id pub key into the instance’s &lt;code&gt;authorized_key&lt;/code&gt; file&lt;/p&gt;

&lt;p&gt;The last role is installing docker into the instance, after that you can use any docker command like &lt;code&gt;sudo docker&lt;/code&gt; or &lt;code&gt;sudo docker-compose&lt;/code&gt; in the instance and it’s armed with docker engine now.&lt;/p&gt;

&lt;p&gt;OK now we have a provisioned instance and keep lego it with any application you write. I will suggest to use Ansible docker service as well to depoly your application based on docker image.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Https for everything</title>
      <link>https://blog.hujiale.me/post/https-for-everything/</link>
      <pubDate>Fri, 18 Nov 2016 00:59:57 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/https-for-everything/</guid>
      <description>

&lt;p&gt;HTTPS is highly recommended for every web site, as a web developer I am building both my personal
and company app under https. Applying for the certificates could be a block for you to migrate/build
your site to https as you need to pay for it and it could take quite a while. Thanks to &lt;a href=&#34;https://letsencrypt.org/&#34;&gt;letsencrypt&lt;/a&gt;
now we can have free open certificate authorify for our sites.&lt;/p&gt;

&lt;p&gt;I will list the least steps to build a site by using &lt;a href=&#34;https://certbot.eff.org/&#34;&gt;certbot&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&#34;install-certbot&#34;&gt;Install certbot&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;wget https://dl.eff.org/certbot-auto
chmod a+x ./certbot-auto
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that, you can run &lt;code&gt;./certbot-auto --help&lt;/code&gt; to check if it&amp;rsquo;s installed successfully.&lt;/p&gt;

&lt;h4 id=&#34;use-certbot-to-generate-certificates&#34;&gt;Use certbot to generate certificates&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./certbot-auto certonly --standalone -d www.yourdomain.com -d sub.yourdomain.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Make sure &lt;code&gt;www.yourdomain.com&lt;/code&gt; and &lt;code&gt;sub.yourdomain.com&lt;/code&gt; is online at &lt;code&gt;80&lt;/code&gt; port as this command will
check the validation. You can ignore &lt;code&gt;--standalone&lt;/code&gt; at the moment, it&amp;rsquo;s just a plugin
for certbot to generated software independent certificates. After running the command, there will be 4 files generated
at &lt;code&gt;/etc/letsencrypt&lt;/code&gt;. They are &lt;code&gt;privKey.pem&lt;/code&gt;, &lt;code&gt;fullchain.pem&lt;/code&gt;, &lt;code&gt;cert.pem&lt;/code&gt; and &lt;code&gt;chain.pem&lt;/code&gt;.
Usually the web server only needs to point to the previous two for enableing https.
I will go through you how to point to certificates ad different server (nginx, apache) has different way.
You can google for it by yourself&lt;/p&gt;

&lt;h4 id=&#34;renew-the-certificates&#34;&gt;Renew the certificates&lt;/h4&gt;

&lt;p&gt;The certificates are only valid for 90 days, luckily the renew is easy.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;./certbot-auto renew
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it. If certbot check the certificates are due for renewal, it will renew them.
I also create a daily cron task to renew it automatically.
&lt;code&gt;0 0 * * * ~/certbot-auto renew&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;https://certbot.eff.org/docs/using.html#getting-certificates-and-choosing-plugins&#34;&gt;Reference&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to make ngrx/store work with HMR</title>
      <link>https://blog.hujiale.me/post/how-to-make-ngrx-store-work-with-hmr/</link>
      <pubDate>Sun, 11 Sep 2016 03:26:53 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/how-to-make-ngrx-store-work-with-hmr/</guid>
      <description>

&lt;p&gt;In my previous post, I talked of a way to develop angular 2 app with HMR.
The vendors I use are &lt;em&gt;@angularclass/hmr&lt;/em&gt; and &lt;em&gt;@angularclass/hmr-loader&lt;/em&gt;
Later on, I thought I might need a data flow tool like redux to manage my app state and I found &lt;a href=&#34;https://github.com/ngrx/store&#34;&gt;ngrx/store&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;@angularclass/hmr injects some &lt;em&gt;hmr&lt;/em&gt; prefix life cycles into the main module to let you to restore the data.
But app state management is optional and you can choose your own way to implement it, so I will walk you through how I implement HMR with ngrx/store&lt;/p&gt;

&lt;h3 id=&#34;retrieve-the-current-state&#34;&gt;Retrieve the current state&lt;/h3&gt;

&lt;p&gt;To retrive the current app state before it&amp;rsquo;s deposed is easy, just subscribe it:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;this._store.take(1).subscribe(s =&amp;gt; store.rootState = s)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it&lt;/p&gt;

&lt;h3 id=&#34;restore-the-current-state&#34;&gt;Restore the current state&lt;/h3&gt;

&lt;p&gt;This is kinda cumbesome as &lt;code&gt;ngrx/store&lt;/code&gt; doesn&amp;rsquo;t provide a way to set the root state, I need to compose a rootReducer to do this.
With the help of &lt;a href=&#34;https://github.com/MikeRyan52&#34;&gt;Mike Ryan&lt;/a&gt;, I figure out a way to do that.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;function stateSetter(reducer: ActionReducer&amp;lt;any&amp;gt;): ActionReducer&amp;lt;any&amp;gt; {
  return function (state, action ) {
    if (action.type === &#39;SET_ROOT_STATE&#39;) {
      return action.payload
    }
    return reducer(state, action)
  }
}

const rootReducer = compose(stateSetter, combineReducers)({
    // your reducers here
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can dispatch a &lt;code&gt;SET_ROOT_STATE&lt;/code&gt; action to reset the app state to what I have stored&lt;/p&gt;

&lt;h3 id=&#34;get-everything-together&#34;&gt;Get everything together&lt;/h3&gt;

&lt;p&gt;This is very much based on &lt;a href=&#34;https://github.com/mgechev/angular2-seed&#34;&gt;angular2-seed&lt;/a&gt;, you might have your own &lt;code&gt;main.ts&lt;/code&gt; though&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;import { platformBrowserDynamic } from &#39;@angular/platform-browser-dynamic&#39;
import { BrowserModule } from &#39;@angular/platform-browser&#39;
import { RouterModule } from &#39;@angular/router&#39;
import { NgModule, ApplicationRef } from &#39;@angular/core&#39;
import { removeNgStyles, createNewHosts, createInputTransfer, bootloader } from &#39;@angularclass/hmr&#39;

import { compose} from &#39;@ngrx/core/compose&#39;
import { Store, StoreModule, ActionReducer, combineReducers } from &#39;@ngrx/store&#39;
import { StoreDevtoolsModule } from &#39;@ngrx/store-devtools&#39;
import { StoreLogMonitorModule, useLogMonitor } from &#39;@ngrx/store-log-monitor&#39;

import { AppModule } from &#39;./app&#39;
import { AppComponent } from &#39;./app/app.component&#39;
import { message } from &#39;./reducer&#39;


// Generate a reducer to set the root state
function stateSetter(reducer: ActionReducer&amp;lt;any&amp;gt;): ActionReducer&amp;lt;any&amp;gt; {
  return function (state, action ) {
    if (action.type === &#39;SET_ROOT_STATE&#39;) {
      return action.payload
    }
    return reducer(state, action)
  }
}

const rootReducer = compose(stateSetter, combineReducers)({
  message
})

let imports = [
  BrowserModule,
  RouterModule.forRoot([], {
    useHash: true
  }),
  // app
  AppModule,
  // vendors
  StoreModule.provideStore(rootReducer)
]

// Enable HMR and ngrx/devtools in hot reload mode
if (module.hot) imports.push(...[
    StoreDevtoolsModule.instrumentStore({
      monitor: useLogMonitor({
        visible: true,
        position: &#39;right&#39;
      })
    }),
    StoreLogMonitorModule,
])

@NgModule({
  bootstrap: [ AppComponent ],
  declarations: [ AppComponent ],
  imports
})
class MainModule {
  constructor(public appRef: ApplicationRef, private _store: Store&amp;lt;any&amp;gt; ) {}
  hmrOnInit(store) {
    if (!store || !store.rootState) return

    // restore state by dispatch a SET_ROOT_STATE action
    if (store.rootState) {
      this._store.dispatch({
        type: &#39;SET_ROOT_STATE&#39;,
        payload: store.rootState
      })
    }

    if (&#39;restoreInputValues&#39; in store) { store.restoreInputValues() }
    this.appRef.tick()
    Object.keys(store).forEach(prop =&amp;gt; delete store[prop])
  }
  hmrOnDestroy(store) {
    const cmpLocation = this.appRef.components.map(cmp =&amp;gt; cmp.location.nativeElement)
    this._store.take(1).subscribe(s =&amp;gt; store.rootState = s)
    store.disposeOldHosts = createNewHosts(cmpLocation)
    store.restoreInputValues  = createInputTransfer()
    removeNgStyles()
  }
  hmrAfterDestroy(store) {
    store.disposeOldHosts()
    delete store.disposeOldHosts
  }
}

export function main() {
  return platformBrowserDynamic().bootstrapModule(MainModule)
}

bootloader(main)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the state remains the same after you change your code with HMR on, cool right.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Angular2 HMR with backend server supported</title>
      <link>https://blog.hujiale.me/post/ng2-hmr-with-backend-server/</link>
      <pubDate>Sat, 03 Sep 2016 20:53:14 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/ng2-hmr-with-backend-server/</guid>
      <description>&lt;p&gt;Currenly I am developing a client + server side boilerplate with &lt;a href=&#34;https://angular.io&#34;&gt;Angular 2&lt;/a&gt; and &lt;a href=&#34;http://feathersjs.com&#34;&gt;Feathers&lt;/a&gt;.
For server side, I am using &lt;code&gt;ts-node&lt;/code&gt; with nodemon, so far so good. But I find it cumbesome that every time I need to bundle client side code.&lt;br /&gt;
After some exploring, I find a way to solve the problem. These are the dependencies:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/AngularClass/angular2-hmr&#34;&gt;angular2-hmr&lt;/a&gt; a bootload wrapper on &lt;code&gt;bootstrapModule&lt;/code&gt;, it&amp;rsquo;s cleared classified how to use in github&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/AngularClass/angular2-hmr-loader&#34;&gt;angular2-hmr-loader&lt;/a&gt;, a webpack loader to work with the previous one&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/webpack/webpack-dev-middleware&#34;&gt;webpack-dev-middleware&lt;/a&gt;, just like &lt;code&gt;webpack-dev-server&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/glenjamin/webpack-hot-middleware&#34;&gt;webpack-hot-middleware&lt;/a&gt;, an &lt;code&gt;express&lt;/code&gt;/&lt;code&gt;feather&lt;/code&gt; middleware just like &lt;code&gt;webpack-dev-server&lt;/code&gt; w/ hot&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of their READMEs clearly walk you through, it just suprises me that few information could be connected on this while it&amp;rsquo;s a quite general practice in &lt;code&gt;React&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Vertical align an unknown size image</title>
      <link>https://blog.hujiale.me/post/vertical-align-an-image/</link>
      <pubDate>Sun, 27 Mar 2016 01:32:00 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/vertical-align-an-image/</guid>
      <description>&lt;p&gt;Some ways to vertiacl align an image in a div, the image&amp;rsquo;s width and height are unknown&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use a helper incline-block div to vertica the image. The helper&amp;rsquo;s width is 0&lt;/li&gt;
&lt;li&gt;Use a tricky way top, right, bottom, left all 0 and margin auto&lt;/li&gt;
&lt;li&gt;Use css transform translateY&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&#34;http://codepen.io/elaijuh/pen/pygbBy&#34;&gt;demo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Unit test Angular directive</title>
      <link>https://blog.hujiale.me/post/unit-test-angular-directive/</link>
      <pubDate>Wed, 17 Jun 2015 01:27:00 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/unit-test-angular-directive/</guid>
      <description>

&lt;p&gt;I seldom test angular directive unless there is some DOM mutation being processed in the directive, like add/remove classes, show/hide elements or compile/destroy elements. If you have a heavy  dependencies on directives, the unit test will be a little bit clunky as for mocking the inline controller of the required directive. Stack overflow gives several alternatives to do so, I am picking two of them which I prefer to go  and demo them here. At the bottom of this post, I will attach the SO link for reference.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Let say we have two directives &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; here and bar is requiring foo for it&amp;rsquo;s controller. We want to test directive &lt;code&gt;bar&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// index.html
// &amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;{{bar}}&amp;lt;/bar&amp;gt;&amp;lt;/foo&amp;gt;

// app.js
app
  .directive(&#39;foo&#39;, function () {
    return {
      restrict: &#39;EA&#39;,
      controller: function () {
        this.getFoo = function () {
          return &#39;foo&#39;;
        };
      },
      link: angular.noop
    }
  })
  .directive(&#39;bar&#39;, function () {
    return {
      restrict: &#39;EA&#39;,
      require: &#39;^foo&#39;,
      link: function (scope, elm, attrs, controller) {
        var fooCtrl = controller;
        scope.bar = fooCtrl.getFoo() + &#39;bar&#39;;
      }
    };
  });
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;bind-controller-to-element-data&#34;&gt;Bind controller to element.data&lt;/h3&gt;

&lt;p&gt;Fundamentally Angular will bind directive&amp;rsquo;s inline controller object to it&amp;rsquo;s DOM through data property. When child directive is requiring parent directive, it will finally find the controller object in element.data. Based on this mechanism, we can mock parent directive controller by element.data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// speca.js

var $scope, element;
beforeEach(inject(function($rootScope, $compile) {
  $scope = $rootScope.$new();
  element = angular.element(&#39;&amp;lt;bar&amp;gt;&amp;lt;/bar&amp;gt;&#39;);
  // bind the controller to element.data
  element.data(&#39;$fooController&#39;, {
    getFoo: function () { return &#39;foo&#39;; }
  });
  $compile(element)($scope);
}));

it(&#39;should bind bar to scope&#39;, function() {
  expect($scope.bar).toEqual(&#39;foobar&#39;);
}); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;inject-the-directive&#34;&gt;Inject the directive&lt;/h3&gt;

&lt;p&gt;Another way is to inject the parent directive and mock it&amp;rsquo;s controller property directly. This is also a straightforward way. But you might need to compile from parent directive even if you only want to test the child directive. See the example below:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var $scope, element;
beforeEach(inject(function($rootScope, $compile, _fooDirective_) {
  var fooDirective = _fooDirective_[0];
  fooDirective.controller = function () {
    this.getFoo = function () { return &#39;foo&#39;; };
  };
    
  $scope = $rootScope.$new();
  // compile from parent directive foo
  element = angular.element(&#39;&amp;lt;foo&amp;gt;&amp;lt;bar&amp;gt;&amp;lt;/bar&amp;gt;&amp;lt;/foo&amp;gt;&#39;);
  $compile(element)($scope);
}));

it(&#39;should bind bar to scope&#39;, function() {
  expect($scope.bar).toEqual(&#39;foobar&#39;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I have  a &lt;a href=&#34;http://plnkr.co/edit/CUvQi8LQQ13fwHdgzgpw?p=preview&#34;&gt;plunker&lt;/a&gt; here to demo both ways of unit testing. And all that shedding light on me is this &lt;a href=&#34;http://stackoverflow.com/questions/19227036/testing-directives-that-require-controllers&#34;&gt;SO&lt;/a&gt; post.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Scope, the most important thing in JavaScript</title>
      <link>https://blog.hujiale.me/post/scope-the-most-important-thing-in-javascript/</link>
      <pubDate>Sat, 31 Jan 2015 23:07:59 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/scope-the-most-important-thing-in-javascript/</guid>
      <description>&lt;p&gt;cope and scope chain, the most important mechanism in JavaScript, are barely clearly explained though specified in ECMA-262 version 5.1. Without scope mechanism, there wouldn&amp;rsquo;t be closure and functional programming. This post is aim to elaborate what happens behind from the very beginning when control enters the global code to execution end.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Firstly, for easy literal, let&amp;rsquo;s agree on the following abbreviation:
&lt;code&gt;GE&lt;/code&gt;: Global Environment
&lt;code&gt;VE&lt;/code&gt;: Variable Environment
&lt;code&gt;LE&lt;/code&gt;: Lexical Environment
&lt;code&gt;OLE&lt;/code&gt;: Outer Lexcial Environment Reference
&lt;code&gt;ER&lt;/code&gt;: Environment Record
&lt;code&gt;EC&lt;/code&gt;: Execution Context
&lt;code&gt;go&lt;/code&gt;: global object (window for browser, global for NodeJS)&lt;/p&gt;

&lt;p&gt;Take following &lt;strong&gt;foo.js&lt;/strong&gt; as example, let&amp;rsquo;s dive into it line by line&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// foo.js
var a = 1;
function Foo(b) {
	b = 3;
	console.log(b); // 3
	console.log(a); // 1
}
console.log(a);
Foo(2);
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Step 1: Control enters into global code
Every javascript file is executed from global code, when the control enters into the global code (before executing the code ), a global EC will be created and push into the EC stack. &lt;code&gt;this&lt;/code&gt; is set to &lt;code&gt;go&lt;/code&gt;. &lt;code&gt;VE&lt;/code&gt; is set to &lt;code&gt;GE&lt;/code&gt; and associated with global &lt;code&gt;EC&lt;/code&gt;. &lt;code&gt;LE&lt;/code&gt; is set to &lt;code&gt;GE&lt;/code&gt; and associated with global &lt;code&gt;EC&lt;/code&gt;. &lt;code&gt;GE&lt;/code&gt; is a javascript internal object which contains &lt;code&gt;ER&lt;/code&gt;(bind with &lt;code&gt;go&lt;/code&gt;) and &lt;code&gt;OLE&lt;/code&gt;(initialized to null). So at this stage, the global &lt;code&gt;EC&lt;/code&gt; looks like:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// step 1
GlobalEC: {
	VE: { 
		ER: { window: go }
		OLE: null
	},
	LE: {
		ER: { window: go }
		OLE: null
	}
	this: window
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Step 2: Declaration Binding Instantiation for global EC
After the execution context is created, control will scan the code (not execution) and bind each function declaration and variable declaration. At this stage, &lt;code&gt;VE&lt;/code&gt; and &lt;code&gt;LE&lt;/code&gt; will be augmented the same way, ie. &lt;code&gt;VE&lt;/code&gt; is same as &lt;code&gt;LE&lt;/code&gt;.  So the global EC looks like:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// step 2
GlobalEC: {
	VE: { 
		ER: { window: go, a: undefined, Foo: foo }
		OLE: null
	},
	LE: {
		ER: { window: go, a: undefined, Foo: foo }
		OLE: null
	}
	this: window
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tricky part is when control scans to &lt;code&gt;Foo&lt;/code&gt;&amp;rsquo;s function declaration, it will create a new function object &lt;code&gt;foo&lt;/code&gt; and associate it with &lt;code&gt;Foo&lt;/code&gt;. The common internal properties and special internal properties for function will be assigned to &lt;code&gt;foo&lt;/code&gt;. One of these internal properties is &lt;code&gt;[[scope]]&lt;/code&gt;, from here the scope chain mechanism starts. &lt;code&gt;foo.[[scope]]&lt;/code&gt; is set to current &lt;code&gt;EC.LE&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Step 3: Executing the global code
After the control finishes scanning the code in step 2, it starts to run the code line by line. During the execution, &lt;code&gt;LE&lt;/code&gt; will be updated with the value bound to the variable in &lt;code&gt;ER&lt;/code&gt;, but &lt;code&gt;VE&lt;/code&gt; remains unchanged. And remember &lt;code&gt;foo.[[scope]]&lt;/code&gt; is set to &lt;code&gt;LE&lt;/code&gt; by reference, so it will be updated accordingly. So before the control enters &lt;code&gt;Foo&lt;/code&gt;&amp;rsquo;s code by calling &lt;code&gt;Foo()&lt;/code&gt;, the &lt;code&gt;GlobalEC&lt;/code&gt; looks like:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// step 3
GlobalEC: {
	VE: { 
		ER: { window: go, a: undefined, Foo: foo }
		OLE: null
	},
	LE: {
		ER: { window: go, a: 1, Foo: foo }
		OLE: null
	}
	this: window
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Step 4: Control enters into Foo&amp;rsquo;s code
By calling &lt;code&gt;Foo()&lt;/code&gt;, the control enters Foo&amp;rsquo;s code. Much like the control enters into global code, it will create a &lt;code&gt;EC&lt;/code&gt; for &lt;code&gt;Foo&lt;/code&gt; and push it into the EC stack on the top of global EC. Then it will create &lt;code&gt;VE&lt;/code&gt; and &lt;code&gt;LE&lt;/code&gt; with a null &lt;code&gt;ER&lt;/code&gt; associated. The tricky difference is &lt;code&gt;OLE&lt;/code&gt; is set to &lt;code&gt;foo.[[scope]]&lt;/code&gt; which is global &lt;code&gt;EC.LE&lt;/code&gt;. The scope chain is established right from here. At this stage, &lt;code&gt;FooEC&lt;/code&gt; looks like:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// step 4
FooEC: {
	VE: { 
		ER: null
		OLE: foo.[[scope]] // GlobalEC.LE
	},
	LE: {
		ER: null
		OLE: foo.[[scope]] // GlobalEC.LE
	}
	this: window
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Step 5: Declaration Binding Instantiation for Foo EC
Like it does in global code, the control will scan the function body before executing it, to bind the function declaration and variable declaration into &lt;code&gt;ER&lt;/code&gt;. Additionally for function code, the formal parameters will be bound to &lt;code&gt;ER&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// step 5
FooEC: {
	VE: { 
		ER: {b: 2}
		OLE: foo.[[scope]] // GlobalEC.LE
	},
	LE: {
		ER: {b: 2}
		OLE: foo.[[scope]] // GlobalEC.LE
	}
	this: window
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Step 6: Executing the Foo code
After scanning the function code, the control starts to execute the function line by line. During this stage, &lt;code&gt;LE&lt;/code&gt; is likely to be updated while &lt;code&gt;VE&lt;/code&gt; remains unchanged.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// step 5
FooEC: {
	VE: { 
		ER: {b: 2}
		OLE: foo.[[scope]] // GlobalEC.LE
	},
	LE: {
		ER: {b: 3}
		OLE: foo.[[scope]] // GlobalEC.LE
	}
	this: window
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When control comes to &lt;code&gt;console.log(b)&lt;/code&gt;, it will first find the variable &lt;code&gt;b&lt;/code&gt; in &lt;code&gt;LE.ER&lt;/code&gt; and value 3 is retrieved. When control comes to &lt;code&gt;console.log(a)&lt;/code&gt;, it will first try to find the variable &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;LE.ER&lt;/code&gt;. Unluckily , this time there is no &lt;code&gt;a&lt;/code&gt; to be found, the control keeps finding &lt;code&gt;a&lt;/code&gt; in &lt;code&gt;LE.OLE&lt;/code&gt; which is &lt;code&gt;GlobalEC.LE&lt;/code&gt;, finally &lt;code&gt;a&lt;/code&gt; is found in &lt;code&gt;GlobalEC.LE.ER&lt;/code&gt; with value bound to 1.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ecma-international.org/ecma-262/5.1/#sec-13.2&#34;&gt;ecma-262 5.1 sec-13.2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ecma-international.org/ecma-262/5.1/#sec-10.4.3&#34;&gt;ecma-262 5.1 sec-10.4.3&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hoisting, what happens behind it</title>
      <link>https://blog.hujiale.me/post/hoisting-what-happen-behind-it/</link>
      <pubDate>Thu, 01 Jan 2015 01:55:22 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/hoisting-what-happen-behind-it/</guid>
      <description>&lt;p&gt;We always see the word &lt;strong&gt;hoisting&lt;/strong&gt; in some javascript books and technical blogs. Hoisting is grabbed to explain the phenomenon that we can use a variable before we declare it. That&amp;rsquo;s sound incredible in compiling languages, but in javascript it&amp;rsquo;s really there. Some people might think that the interpretor do a magic to restructure the code and put all variable/function declaration statements at the top of the function body. Thinking like that way might help to write or read the program, but that&amp;rsquo;s not the things truely happen behind. The post is to walk through the mechanism behind hoisting.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function foo(x) {
	console.log(x); // x
	console.log(y); // undefined
	console.log(z); // [function: z]

	z(); // z

	var y = &#39;y&#39;;
	var z = &#39;z&#39;;

	function z() { // overwrite var z
		console.log(&#39;z&#39;);
	}
}

foo(&#39;x&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are 3 kinds of scopes in javascript - &lt;code&gt;global scope&lt;/code&gt;, &lt;code&gt;function scope&lt;/code&gt;, &lt;code&gt;eval scope&lt;/code&gt;. We only discuss function scope here. Whenever a function is invoked, the execution context is put on the top of the stack, and before executing the function code step-by-step, there is a pre-stage called &lt;code&gt;Declaration Binding Instantiation&lt;/code&gt;. In this declaration binding stage, an &lt;code&gt;VariableEnvironment&lt;/code&gt;(VE) (in old ECMA-262, it&amp;rsquo;s refered as variable object) is created. Run-time function will refer to this &lt;code&gt;VariableEnvironment&lt;/code&gt; (actually it should be &lt;code&gt;LexicalEnvironment&lt;/code&gt; which is initialized the same as &lt;code&gt;VariableEnvironment&lt;/code&gt;) to identify the variables. So below is what the declaration binding stage do in sequence&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Formal parameters are bound to VE&lt;/li&gt;
&lt;li&gt;Function declaration is bound to VE. If the function name is already existing, it will overwrite it.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Arguments&lt;/code&gt; is bound to VE.&lt;/li&gt;
&lt;li&gt;Variable declaration is bound to VE. If the variable name is already existing, it will do nothing.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;VE for &lt;code&gt;foo&lt;/code&gt; should look like:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;/*
VE = {
    x: &#39;x&#39;, // formal parameter x
    z: [function z], // reference to function z
    arguments:
    y: undefined
};
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So before the execution of the function, all variables/functions are bound to VE already to be later referenced. Now you know the magic behind hoisting.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ecma-international.org/ecma-262/5.1/#sec-10.5&#34;&gt;http://www.ecma-international.org/ecma-262/5.1/#sec-10.5&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Repeat a capturing group, pitfall in RegExp</title>
      <link>https://blog.hujiale.me/post/repeat-a-capturing-group/</link>
      <pubDate>Tue, 23 Dec 2014 01:41:37 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/repeat-a-capturing-group/</guid>
      <description>&lt;p&gt;RegExp is esoteric, known to all, but you will find it incredibly effecient when you start to get used to it. I like to use RegExp, but sometimes I tend to make mistakes, the most common of which is to repeat a capturing group. Let&amp;rsquo;s think about this. Given a string &lt;code&gt;&#39;a=1;b=2;...;k=n&#39;&lt;/code&gt;, I would like to capture &lt;code&gt;k, n&lt;/code&gt; of each pair to form an array like &lt;code&gt;[&#39;a&#39;, 1, &#39;b&#39;, 2, ... &#39;k&#39;, n]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Below is our first try:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var s = &#39;a=1;b=2;c=3&#39;;
var r = /(?:(\w)=(\d))?(?:;(\w)=(\d))*/;

// expected to be [&#39;a&#39;, 1, &#39;b&#39;, 2, &#39;c&#39;, 3]
s.match(r).slice(1, 7); // [&#39;a&#39;, 1, &#39;c&#39;, 3] !ops
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, &lt;code&gt;b, 2&lt;/code&gt; is lost. What happens behind is, when RegExp engine finishes matching for group 3 (which is &amp;lsquo;b&amp;rsquo;) and group 4 (which is 2) it finds the &lt;code&gt;*&lt;/code&gt; which makes it redo the match for group 3 and 4 from last index. So &lt;code&gt;b, 2&lt;/code&gt; is overridden by &lt;code&gt;c, 3&lt;/code&gt;. Here we are trying to repeat a capturing group &lt;code&gt;(?:;(\w)=(\d))*&lt;/code&gt; which leads to the unexpected result.&lt;/p&gt;

&lt;p&gt;So can we achieve the goal by global matching? Let&amp;rsquo;s do the second try:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var s = &#39;a=1;b=2;c=3&#39;;
var r = /(?:(\w)=(\d))/g;

// expected to be [&#39;a&#39;, 1, &#39;b&#39;, 2, &#39;c&#39;, 3]
s.match(r); // [&#39;a=1&#39;, &#39;b=2&#39;, &#39;c=3&#39;] !ops
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Looks like it&amp;rsquo;s even further from what we expected. That&amp;rsquo;s true, in global matching, capturing group lose it&amp;rsquo;s magic and it always return the matching result as a whole RegExp.&lt;/p&gt;

&lt;p&gt;Finally we yield to use some JavaScript snippet, various ways to go, not to address here.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;a href=&#34;http://www.regular-expressions.info/captureall.html&#34;&gt;http://www.regular-expressions.info/captureall.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Handle HTTP request in multiple processes in NodeJS</title>
      <link>https://blog.hujiale.me/post/handle-http-request-in-multiple-process/</link>
      <pubDate>Tue, 16 Dec 2014 01:28:26 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/handle-http-request-in-multiple-process/</guid>
      <description>&lt;p&gt;NodeJS is single process based which is good at frequent IO operations. But single process can&amp;rsquo;t fully utilize multi-core CPU. Luckily we have &lt;code&gt;child-process&lt;/code&gt; module in NodeJS to spawn multiple processes. One of the practical examples is handling HTTP request, especially for a large number of concurrent requests. A common way is to use master-worker pattern, a master process working as a proxy to delegate the HTTP requests to child processes with load balance enabled. Cons of master-worker is rapid resource consuming as each process needs to listen on a different port. Another ninja way is to make each child process listen on the same port. Let&amp;rsquo;s have a look at how to achieve that:&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;// master.js
var cp = require(&#39;child_process&#39;),
    cp1 = cp.fork(&#39;child-process.js&#39;),
    cp2 = cp.fork(&#39;child-process.js&#39;),
    net = require(&#39;net&#39;);

var server = net.createServer(); // create a TCP server

server.on(&#39;listening&#39;, function () {
    /**
     * this is a tricky part
     * it&#39;s not sending the whole server object
     * but a stringified message object with server._handle in
     * we will have another post to discuss it later
     */
    cp1.send(&#39;server&#39;, server);
    cp2.send(&#39;server&#39;, server);
    server.close();
});

server.listen(1337);

// child.js
var http = require(&#39;http&#39;);

var server = http.createServer(function (req, res) {
   res.writeHead(200, {&#39;Content-Type&#39;: &#39;text/plain&#39;}); 
   res.end(&#39;handled by child, pid: &#39; + process.pid + &#39;\n&#39;);
});

process.on(&#39;message&#39;, function (m, tcpServer) {
   if (m === &#39;server&#39;) {
      tcpServer.on(&#39;connection&#39;, function (socket) {
          server.emit(&#39;connection&#39;, socket);
      });
   }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;master.js&lt;/code&gt;, we create a TCP server, have it bound to port 1337, and close it immediately once delegate it to child process. In &lt;code&gt;child.js&lt;/code&gt;, we create a HTTP server, not like usual, it doesn&amp;rsquo;t listen on any port explicitly. Now we have the TCP server sent from master process (regard it to be the same TCP server instance for now, but actually not. We will discuss it in another post). Once there is connection to the TCP server, we manually emit the &lt;code&gt;connection&lt;/code&gt; event on HTTP server with the TCP socket passed in. So that any HTTP reqeust to port 1337 will be handled by child process now, one process at a time. Let&amp;rsquo;s use curl to check the result:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ curl http://localhost:1337
handled by child, pid: 18169 
$ curl http://localhost:1337
handled by child, pid: 18168
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title> $provide.decorator - tweak Angular servicer</title>
      <link>https://blog.hujiale.me/post/angularjs-decorator/</link>
      <pubDate>Thu, 11 Dec 2014 22:56:24 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/angularjs-decorator/</guid>
      <description>&lt;p&gt;If you are using Angular, you can&amp;rsquo;t avoid depending on third-party modules. Sometimes you find it not that perfect API the module provides, so that you hack into the source code and about to pull request. But the author&amp;rsquo;s comments on your pull request, usually for popular repo, &amp;lsquo;sorry-that&amp;rsquo;s not our priority&amp;rsquo; turns you down totally. Either you work around it or turns to another third-party module. Here is the third option, if you want to share the private data in service closure and provide some API for your specific need, you might find &lt;code&gt;$provide.decorator&lt;/code&gt; helpful. Let&amp;rsquo;s look at this:&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;angular
    .module(&#39;sortModule&#39;, [])
    .factory(&#39;sortService&#39;, function () {
        var list = [1, 3, 10, 2];
        var service = {
            doSort: doSort
        }
        return service;
        ////////////////
        function doSort() {
            return list.sort().slice(); // [1, 10, 2, 3] default sort method compared by string
        }
    });

var myApp = angular.module(&#39;myApp&#39;, [&#39;sortModule&#39;]);
myApp.config(function ($provide) {
    $provide.decorator(&#39;sortService&#39;, function ($delegate) {
        $delegate.doCustSort = function (fn) {
            return list.sort(fn).slice(); // [1, 2, 3, 10] compared by number
        };
        
        return $delegate;
    });
});

myApp.controller(&#39;MyCtrl&#39;, function($scope, sortService) {
    console.log(sortService.doSort()); // [1, 10, 2, 3]
    var compare = function (a, b) {
        if (a &amp;lt; b) return -1;
        if (a &amp;gt; b) return 1;
        return 0;
    };
    // we tweaked sortService with doCustSort method
    console.log(sortService.doCustSort(compare)); // [1, 2, 3, 10]
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we add a customized sort method &lt;code&gt;doCustSort&lt;/code&gt; to &lt;code&gt;$delegate&lt;/code&gt; which references to the service itself. So that we can share the private &lt;code&gt;list&lt;/code&gt; and do some specific logic on our need. And basically you can tweak most components in Angular as long as it&amp;rsquo;s a &lt;code&gt;$provide&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://plnkr.co/edit/etgYtx?p=preview&#34;&gt;Plnkr demo&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Function overload in JavaScript</title>
      <link>https://blog.hujiale.me/post/function-overload-in-javascript/</link>
      <pubDate>Thu, 04 Dec 2014 01:14:12 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/function-overload-in-javascript/</guid>
      <description>&lt;p&gt;As we know, Javscript has no function overload in nature. If you try to declare the same function with different signature, the previous one will be overwritten rather than overloaded. As function overload in most OO programming languages are by means of parameters, it operates on different logic according to the passed in parameters. So there is still a way to do function overload in JS.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var foo = {
    bar: function () {
        switch (arguments.length) {
            case 0:
                console.log(0);
                break;
            case 1:
                console.log(arguments[0]);
                break;
            case 2:
                console.log(arguments[0] + arguments[1]);
                break;
        }
    }
}

foo.bar(); // 0
foo.bar(1); // 1
foo.bar(1, 2); // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This approach is workable but not tidy and flexiable. With more and more overloads, the switch block becomes longer and longer scaring away developers.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;function.length&lt;/code&gt; and &lt;code&gt;closure&lt;/code&gt;, we could implement the same in a neat and ninja way.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var foo = {
    overloadMethod: function (name, fn) {
        var baseFn = this[name];
        this[name] = function () {
            if (fn.length === arguments.length) {
                return fn.apply(this, arguments);
            } else if (typeof baseFn === &#39;function&#39;) {
                return baseFn.apply(this, arguments); // baseFn is in a closure
            }
        };
    }
};

foo.overloadMethod(&#39;bar&#39;, function() {
    console.log(0);
})
foo.overloadMethod(&#39;bar&#39;, function(x) {
    console.log(x);
})
foo.overloadMethod(&#39;bar&#39;, function(x, y) {
    console.log(x + y);
})


foo.bar(); // 0
foo.bar(1); // 1
foo.bar(1, 2); // 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So everytime you want to overload the method, just call &lt;code&gt;foo.overloadMethod&lt;/code&gt; with the method name and anonymous function passed in. It looks like &lt;code&gt;foo.bar&lt;/code&gt; is overwritten again and again, but actually every single version of &lt;code&gt;foo.bar&lt;/code&gt; is completely kept in closure to be referenced.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Reference book: &lt;a href=&#34;http://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X/ref=sr_1_1?ie=UTF8&amp;amp;qid=1417626477&amp;amp;sr=8-1&amp;amp;keywords=secrets+of+javascript+ninja&#34;&gt;Secrets of the JavaScript Ninja&lt;/a&gt;, &lt;a href=&#34;http://ejohn.org/&#34;&gt;John Resig&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>JavaScript prototype and inheritance</title>
      <link>https://blog.hujiale.me/post/javascript-prototype-and-inheritance/</link>
      <pubDate>Mon, 01 Dec 2014 05:13:52 +0800</pubDate>
      
      <guid>https://blog.hujiale.me/post/javascript-prototype-and-inheritance/</guid>
      <description>

&lt;p&gt;Inheritance in JS is quite different from class based inheritance which is popular for being used in C++ and Java. In class based inheritance language, we have to abstract a class which is not a real world subject. While in prototype based inheritance, we can implement inheritance on objects directly.&lt;/p&gt;

&lt;p&gt;&lt;span class=&#34;more&#34;&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;The post walks you through how to do inheritance in JS.&lt;/p&gt;

&lt;h3 id=&#34;simple-object-inheritance&#34;&gt;Simple object inheritance&lt;/h3&gt;

&lt;p&gt;As every object has an internal property &lt;code&gt;[[prototype]]&lt;/code&gt; which points to it&amp;rsquo;s prototype, we can directly assign a super object to it. [[prototype]] could be implemented in different ways in different browsers. In Chrome and Firefox, it can be refered as &lt;code&gt;__proto__&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var sup = {x: &#39;x&#39;, y: &#39;y&#39;};
var sub = {a: &#39;a&#39;};
console.log(sub.x); // undefined

sub.__proto__ = sup;
console.log(sub.x); // x
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;inheritance-by-prototype-chaining&#34;&gt;Inheritance by prototype chaining&lt;/h3&gt;

&lt;p&gt;In most of the time, especially in OO style, we would like to have a constructor and then create objects from it. In JS, constructor is not a class and not different from any regular function except that you can &lt;code&gt;new&lt;/code&gt; it. Usually a constructor does not explicitly return anything, it&amp;rsquo;s side effect is to assign all the &lt;code&gt;this&lt;/code&gt; properties you defined in the constructor body to the object and return it. A constructor function has a &lt;code&gt;prototype&lt;/code&gt; property which points to the prototype object of the constructor. The object created by the constructor has it&amp;rsquo;s [[prototype]] pointing to the constructor&amp;rsquo;s prototype object. Inheritance is implemented by assigning super object to sub constructor&amp;rsquo;s prototype. Take a look at this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Sup() {
    this.x = &#39;x&#39;;
    this.y = &#39;y&#39;;
}

function Sub() {
    this.a = &#39;a&#39;;
}

Sub.prototype = new Sup();

var sub = new Sub();
console.log(sub.x); // x

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The sub object has no x itself, so it will find x in it&amp;rsquo;s prototype which is a super object. This is cool, but the problem comes when there is reference property in super object.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Sup() {
    this.x = &#39;x&#39;;
    this.z = [&#39;z&#39;];
}

function Sub() {
    this.a = &#39;a&#39;;
}

Sub.prototype = new Sup();

var sub1 = new Sub();
var sub2 = new Sub();
sub1.z.push(&#39;zz&#39;);
console.log(sub1.z); // [&#39;z&#39;, &#39;zz&#39;]
console.log(sub2.z); // [&#39;z&#39;, &#39;zz&#39;], !expected to be [&#39;z&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both sub1.z and sub2.z are pointing to the same z in super object. Any sub object&amp;rsquo;s operation on z will have impact on all sub objects. That&amp;rsquo;s dangerous!&lt;/p&gt;

&lt;h3 id=&#34;classical-inheritance-by-constructor-stealing&#34;&gt;Classical inheritance by constructor stealing&lt;/h3&gt;

&lt;p&gt;Now we see the problem in prototype chaining inheritance, is there a way to solve it?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Sup() {
    this.z = [&#39;z&#39;];
}

function Sub() {
    Sup.call(this);
    this.a = &#39;a&#39;;
}

var sub1 = new Sub();
var sub2 = new Sub();
sub1.z.push(&#39;zz&#39;);
console.log(sub1.z); // [&#39;z&#39;, &#39;zz&#39;]
console.log(sub2.z); // [&#39;z&#39;], !cool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In sub constructor we steal super constructor and call it with &lt;code&gt;this&lt;/code&gt; reference. Now that every sub object has a copy of z and will not interfere with each other. This solves the problem in prototype chaining inheritance, but it&amp;rsquo;s downside is every property including method to be inheritted should be defined inside the super constructor. So there is no method reuse. How about we combine constructor stealing and prototype chaining together?&lt;/p&gt;

&lt;h3 id=&#34;combination-inheritance-pseudoclassical-inheritance&#34;&gt;Combination inheritance (pseudoclassical inheritance)&lt;/h3&gt;

&lt;p&gt;Both prototype chaining inheritance and constructor stealing inheritance have downsides, what if we combine them together?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function Sup() {
    this.z = [&#39;z&#39;];
}
Sup.prototype.mo = function () {
    console.log(&#39;mo&#39;);
};

function Sub() {
    Sup.call(this);
    this.a = &#39;a&#39;;
}
Sub.prototype = new Sup();

var sub1 = new Sub();
var sub2 = new Sub();

sub1.z.push(&#39;zz&#39;);
console.log(sub1.z); // [&#39;z&#39;, &#39;zz&#39;]
sub1.mo(); // mo
console.log(sub2.z); // [&#39;z&#39;]
sub2.mo(); // mo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s cool, we don&amp;rsquo;t need to define methods in super constructor&amp;rsquo;s body and they are reusable now. The combination inheritance addresses both downsides of prototype chaining and constructor stealing. It&amp;rsquo;s widely used in real life. It also preserves the behavior of &lt;code&gt;instanceof&lt;/code&gt; and &lt;code&gt;isPrototypeOf&lt;/code&gt; which looks like perfect now. But, yeah there is always another but :), if you look deep into the pattern, you might find that the super constructor has been called twice, &lt;code&gt;Sup.call(this)&lt;/code&gt; and &lt;code&gt;Sub.prototype = new Sup()&lt;/code&gt; which means the set of properties are duplicated in memory. This is an unavoidable ineffecient part of combination inheritance. And on another hand, combination inheritance still relies on constructor function which is kind of like class inheritance, while JS is really good at inheritance on objects. &lt;a href=&#34;http://www.crockford.com&#34;&gt;Douglas Crockford&lt;/a&gt; has introduced prototypal inheritance in 2006 based on the premise that inheritance on objects.&lt;/p&gt;

&lt;h3 id=&#34;prototypal-inheritance&#34;&gt;Prototypal inheritance&lt;/h3&gt;

&lt;p&gt;So how to do inheritance directly on objects without constructors?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function create(supObj) {
    function Empty() {};
    Empty.prototype = supObj;
    return new Empty();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Crockford introduced a factory like function to create the sub object based on the passed in super object. So super constructor is not a must now. But the type of the sub object is lost. Based on this create function, Crockford introduced parasitic inheritance which is closer to real life.&lt;/p&gt;

&lt;h3 id=&#34;parasitic-inheritance&#34;&gt;Parasitic inheritance&lt;/h3&gt;

&lt;p&gt;Much like prototypal inheritance, parasitic inheritance just encapsulates all the properties or methods for the sub object in one function.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function createAnother(supObj) {
    var sub = create(supObj);
    
    sub.a = &#39;a&#39;;
    sub.mo = function () {
        console.log(&#39;mo&#39;);
    };
    return sub;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the sub object has all the properties of super object and it&amp;rsquo;s own property a and method mo. Parasitic inheritance addresses the duplicated properties downside in combination inheritance, but it loses object type which means &lt;code&gt;instanceof&lt;/code&gt; and &lt;code&gt;isPrototypeOf&lt;/code&gt; don&amp;rsquo;t work for sub object any more. Let&amp;rsquo;s keep improvement, finally we work out a way combining constructor stealing and parasitic inheritance.&lt;/p&gt;

&lt;h3 id=&#34;parasitic-combination-inheritance&#34;&gt;Parasitic combination inheritance&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;function create(supObj) {
    function Empty() {};
    Empty.prototype = supObj;
    return new Empty();
}

function inheritPrototype(Sub, Sup) {
    var subPrototype = create(Sup.prototype);
    subPrototype.constructor = Sub; // link constructor back to Sub
    Sub.prototype = subPrototype;
}

function Sup() {
    this.x = &#39;x&#39;;
    this.z = [&#39;z&#39;];
}

Sup.prototype.mo = function () {
    console.log(&#39;mo&#39;);
};

function Sub() {
    Sup.call(this);
    this.a = &#39;a&#39;;
}

inheritPrototype(Sub, Sup);

var sub1 = new Sub();
var sub2 = new Sub();
sub1.z.push(&#39;zz&#39;);
sub1.mo(); // mo
cnosole.log(sub1.z); // [&#39;z&#39;, &#39;zz&#39;]
sub2.mo(); // mo
console.log(sub2.z); // [&#39;z&#39;]

console.log(sub1 instanceof Sub); // true
console.log(Sub.prototype.isPrototypeOf(sub2)); //true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now both the downside in combination inheritance - duplicated properties and the downside in parasitic inheritance - object type lost are addressed. We are kind of having a perfect inheritance machenism now. BUT&amp;hellip;personally I will not suggest to use inheritance heavily unless you want to mess yourself up.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>