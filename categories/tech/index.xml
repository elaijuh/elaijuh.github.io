<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Tech on moo...</title>
    <link>http://elaijuh.github.io/categories/tech/</link>
    <description>Recent content in Tech on moo...</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 03 Sep 2016 20:53:14 +0800</lastBuildDate>
    <atom:link href="http://elaijuh.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Angular2 HMR with backend server supported</title>
      <link>http://elaijuh.github.io/post/ng2-hmr-with-backend-server/</link>
      <pubDate>Sat, 03 Sep 2016 20:53:14 +0800</pubDate>
      
      <guid>http://elaijuh.github.io/post/ng2-hmr-with-backend-server/</guid>
      <description>Currenly I am developing a client + server side boilerplate with Angular 2 and Feathers. For server side, I am using ts-node with nodemon, so far so good. But I find it cumbesome that every time I need to bundle client side code. After some exploring, I find a way to solve the problem. These are the dependencies: angular2-hmr a bootload wrapper on bootstrapModule, it&amp;rsquo;s cleared classified how to use</description>
    </item>
    
    <item>
      <title>Function overload in JavaScript</title>
      <link>http://elaijuh.github.io/post/function-overload-in-javascript/</link>
      <pubDate>Thu, 04 Dec 2014 01:14:12 +0800</pubDate>
      
      <guid>http://elaijuh.github.io/post/function-overload-in-javascript/</guid>
      <description>As we know, Javscript has no function overload in nature. If you try to declare the same function with different signature, the previous one will be overwritten rather than overloaded. As function overload in most OO programming languages are by means of parameters, it operates on different logic according to the passed in parameters. So there is still a way to do function overload in JS. var foo = { bar: function () { switch (arguments.length) { case 0: console.log(0); break; case 1: console.log(arguments[0]); break; case 2: console.log(arguments[0] + arguments[1]); break; } } } foo.bar(); // 0 foo.bar(1); // 1 foo.bar(1, 2); // 3 This approach is workable but not tidy and flexiable.</description>
    </item>
    
    <item>
      <title>JavaScript prototype and inheritance</title>
      <link>http://elaijuh.github.io/post/javascript-prototype-and-inheritance/</link>
      <pubDate>Mon, 01 Dec 2014 05:13:52 +0800</pubDate>
      
      <guid>http://elaijuh.github.io/post/javascript-prototype-and-inheritance/</guid>
      <description>Inheritance in JS is quite different from class based inheritance which is popular for being used in C++ and Java. In class based inheritance language, we have to abstract a class which is not a real world subject. While in prototype based inheritance, we can implement inheritance on objects directly. The post walks you through how to do inheritance in JS. Simple object inheritance As every object has an internal property [[prototype]] which points to it&amp;rsquo;s prototype, we can directly assign a super object to it.</description>
    </item>
    
  </channel>
</rss>
